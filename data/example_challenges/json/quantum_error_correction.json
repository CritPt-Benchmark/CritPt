{
  "dataset_name": "quantum_error_correction",
  "source_notebook": "data/example_challenges/quantum_error_correction.ipynb",
  "problems": [
    {
      "problem_id": "quantum_error_correction_main",
      "problem_type": "main",
      "problem_index": null,
      "problem_description": "\n\n# Problem setup:\nIn quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.\n\nOur convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are $XXXX$ and $ZZZZ$, where $X$ and $Z$ are Pauli matrices. The logical $X$ and $Z$ operators on the two qubits are $X_A = XIXI$, $X_B=XXII$, $Z_A = ZZII$, $Z_B = ZIZI$, up to multiplication by stabilizers.\n\nWe will consider different state preparation circuits consisting of controlled not $CNOT_{ij}$ gates, where $CNOT_{ij}$ has control qubit $i$ and target qubit $j$. As a simple model of quantum errors in hardware, we will suppose that each $CNOT_{ij}$ gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability $p/15$. The probability $p$ indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity $p$.\n\n# Main problem:\n\nSuppose that we prepare a logical two-qubit $|00\\rangle_{AB}$ state in the [[4,2,2]] code. To do so, we introduce an ancilla qubit, qubit 4, and use the following state preparation circuit:\n\n$$M_4 (CNOT_{04}) (CNOT_{34}) (CNOT_{23}) (CNOT_{10}) (CNOT_{12}) (H_1) $$\n\nNote that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation).  $H$ is a single-qubit Hadamard gate and $M$ is a single-qubit measurement. The ancilla is used to detect errors in the state preparation circuit and makes the circuit fault-tolerant. If the ancilla measurement is $|0\\rangle$ ($|1\\rangle$), the state preparation succeeds (fails).\n\nWhat is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of two-qubit gate error rate $p$, assuming the state is post-selected on all detectable errors in the code and on the ancilla qubit measuring $|0\\rangle$?\n",
      "code_template": "import sympy as sp\n\np = sp.symbols('p')\n\ndef answer(p):\n    r\"\"\"\n    Return the expression of the logical state fidelity of the final 2-qubit logical state\n    at the end of the circuit as a function of two-qubit gate error rate $p$.\n\n    Inputs\n    ----------\n    p: sympy.Symbol, two-qubit gate error rate, $p$\n\n    Outputs\n    ----------\n    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state\n    \"\"\"\n\n    # ------------------ FILL IN YOUR RESULTS BELOW ------------------\n    F_logical = ...  # a SymPy expression of inputs\n    # ---------------------------------------------------------------\n\n    return F_logical",
      "answer_code": "import sympy as sp\n\np = sp.symbols('p')\n\ndef real_answer(p):\n    r\"\"\"\n    Return the expression of the logical state fidelity of the final 2-qubit logical state\n    at the end of the circuit as a function of two-qubit gate error rate $p$.\n\n    Inputs\n    ----------\n    p: sympy.Symbol, two-qubit gate error rate, $p$\n\n    Outputs\n    ----------\n    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state\n    \"\"\"\n\n    # ------------------ FILL IN YOUR RESULTS BELOW ------------------\n    F_logical = 1 - (sp.Rational(16, 25)* p**2 - sp.Rational(128, 125)* p**3 + sp.Rational(2048, 3375)* p**4 - sp.Rational(32768, 253125)* p**5) / (1 - sp.Rational(68, 15)* p + sp.Rational(704, 75)* p**2 - sp.Rational(32768, 3375)* p**3 + sp.Rational(253952, 50625)* p**4 - sp.Rational(262144, 253125)* p**5)\n    # ---------------------------------------------------------------\n\n    return F_logical",
      "answer_only_code": "F_logical = 1 - (sp.Rational(16, 25)* p**2 - sp.Rational(128, 125)* p**3 + sp.Rational(2048, 3375)* p**4 - sp.Rational(32768, 253125)* p**5) / (1 - sp.Rational(68, 15)* p + sp.Rational(704, 75)* p**2 - sp.Rational(32768, 3375)* p**3 + sp.Rational(253952, 50625)* p**4 - sp.Rational(262144, 253125)* p**5)",
      "testcases": null,
      "metadata": {
        "settings": {},
        "tag": " # Tag:\n \"Quantum Information, Science & Technology\"\n",
        "problem_setup": "\n\n# Problem setup:\nIn quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.\n\nOur convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are $XXXX$ and $ZZZZ$, where $X$ and $Z$ are Pauli matrices. The logical $X$ and $Z$ operators on the two qubits are $X_A = XIXI$, $X_B=XXII$, $Z_A = ZZII$, $Z_B = ZIZI$, up to multiplication by stabilizers.\n\nWe will consider different state preparation circuits consisting of controlled not $CNOT_{ij}$ gates, where $CNOT_{ij}$ has control qubit $i$ and target qubit $j$. As a simple model of quantum errors in hardware, we will suppose that each $CNOT_{ij}$ gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability $p/15$. The probability $p$ indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity $p$.",
        "notebook_path": "data/example_challenges/quantum_error_correction.ipynb"
      }
    },
    {
      "problem_id": "quantum_error_correction_sub_0",
      "problem_type": "sub",
      "problem_index": 0,
      "problem_description": "\n\n# Problem setup:\nIn quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.\n\nOur convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are $XXXX$ and $ZZZZ$, where $X$ and $Z$ are Pauli matrices. The logical $X$ and $Z$ operators on the two qubits are $X_A = XIXI$, $X_B=XXII$, $Z_A = ZZII$, $Z_B = ZIZI$, up to multiplication by stabilizers.\n\nWe will consider different state preparation circuits consisting of controlled not $CNOT_{ij}$ gates, where $CNOT_{ij}$ has control qubit $i$ and target qubit $j$. As a simple model of quantum errors in hardware, we will suppose that each $CNOT_{ij}$ gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability $p/15$. The probability $p$ indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity $p$.",
      "code_template": "import sympy as sp\n\np = sp.symbols('p')\n\ndef answer(p):\n    r\"\"\"\n    Return the expression of the physical state fidelity of the final physical 4-qubit state\n    at the end of the circuit as a function of the two-qubit gate error rate $p$.\n\n    Inputs\n    ----------\n    p: sympy.Symbol, two-qubit gate error rate $p$\n\n    Outputs\n    ----------\n    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state\n    \"\"\"\n\n    # ------------------ FILL IN YOUR RESULTS BELOW ------------------\n    F_physical = ...  # a SymPy expression of inputs\n    # ---------------------------------------------------------------\n\n    return F_physical",
      "answer_code": "import sympy as sp\n\np = sp.symbols('p')\n\ndef real_answer(p):\n    r\"\"\"\n    Return the expression of the physical state fidelity of the final physical 4-qubit state\n    at the end of the circuit as a function of the two-qubit gate error rate $p$.\n\n    Inputs\n    ----------\n    p: sympy.Symbol, two-qubit gate error rate $p$\n\n    Outputs\n    ----------\n    F_physical: sympy.Expr, the physical state fidelity of the final physical 4-qubit state\n    \"\"\"\n\n    # ------------------ FILL IN YOUR RESULTS BELOW ------------------\n    F_physical = (1 - sp.Rational(12, 15)* p)**2\n    # ---------------------------------------------------------------\n\n    return F_physical",
      "answer_only_code": "F_physical = (1 - sp.Rational(12, 15)* p)**2",
      "testcases": null,
      "metadata": {
        "settings": {},
        "sub_problem_index": 0,
        "notebook_path": "data/example_challenges/quantum_error_correction.ipynb"
      }
    },
    {
      "problem_id": "quantum_error_correction_sub_1",
      "problem_type": "sub",
      "problem_index": 1,
      "problem_description": "\n\n# Problem setup:\nIn quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.\n\nOur convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are $XXXX$ and $ZZZZ$, where $X$ and $Z$ are Pauli matrices. The logical $X$ and $Z$ operators on the two qubits are $X_A = XIXI$, $X_B=XXII$, $Z_A = ZZII$, $Z_B = ZIZI$, up to multiplication by stabilizers.\n\nWe will consider different state preparation circuits consisting of controlled not $CNOT_{ij}$ gates, where $CNOT_{ij}$ has control qubit $i$ and target qubit $j$. As a simple model of quantum errors in hardware, we will suppose that each $CNOT_{ij}$ gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability $p/15$. The probability $p$ indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity $p$.\n\n## Subproblem 1:\n\nSuppose that we wish to prepare a logical two-qubit GHZ state  $(|00\\rangle_{AB}+|11\\rangle_{AB})/\\sqrt{2}$ in the [[4,2,2]] code. To do so, we use the following state preparation circuit:\n\n$$ (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). $$\n\nNote that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). $H$ is a single-qubit Hadamard gate.\n\nWhat is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate $p$?",
      "code_template": "import sympy as sp\n\np = sp.symbols('p')\n\ndef answer(p):\n    r\"\"\"\n    Return the expression of logical state fidelity of the final 2-qubit logical state\n    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.\n\n    Inputs\n    ----------\n    p: sympy.Symbol, the two-qubit gate error rate, $p$\n\n    Outputs\n    ----------\n    F_logical: sympy.Expr, the logical state fidelity as a function of $p$\n    \"\"\"\n\n    # ------------------ FILL IN YOUR RESULTS BELOW ------------------\n    F_logical = ...  # a SymPy expression of inputs\n    # ---------------------------------------------------------------\n\n    return F_logical",
      "answer_code": "import sympy as sp\n\np = sp.symbols('p')\n\ndef real_answer(p):\n    r\"\"\"\n    Return the expression of logical state fidelity of the final 2-qubit logical state\n    at the end of the circuit as a function of the two-qubit gate error rate $p$ in Sympy format.\n\n    Inputs\n    ----------\n    p: sympy.Symbol, the two-qubit gate error rate, $p$\n\n    Outputs\n    ----------\n    F_logical: sympy.Expr, the logical state fidelity as a function of $p$\n    \"\"\"\n\n    # ------------------ FILL IN YOUR RESULTS BELOW ------------------\n    F_logical = 1 - (sp.Rational(16, 75)* p**2) / (1 - sp.Rational(8, 5)* p + sp.Rational(64, 75)* p**2)\n    # ---------------------------------------------------------------\n\n    return F_logical",
      "answer_only_code": "F_logical = 1 - (sp.Rational(16, 75)* p**2) / (1 - sp.Rational(8, 5)* p + sp.Rational(64, 75)* p**2)",
      "testcases": null,
      "metadata": {
        "settings": {},
        "sub_problem_index": 1,
        "notebook_path": "data/example_challenges/quantum_error_correction.ipynb"
      }
    },
    {
      "problem_id": "quantum_error_correction_sub_2",
      "problem_type": "sub",
      "problem_index": 2,
      "problem_description": "\n\n# Problem setup:\nIn quantum error correction, you encode quantum states into logical states made of many qubits in order to improve their resilience to errors. In quantum error detection, you do the same but can only detect the presence of errors and not correct them. In this problem, we will consider a single [[4,2,2]] quantum error detection code, which encodes two logical qubits into four physical qubits, and investigate how robust logical quantum operations in this code are to quantum errors.\n\nOur convention is that the four physical qubits in the [[4,2,2]] code are labelled 0,1,2,3. The two logical qubits are labelled A and B. The stabilizers are $XXXX$ and $ZZZZ$, where $X$ and $Z$ are Pauli matrices. The logical $X$ and $Z$ operators on the two qubits are $X_A = XIXI$, $X_B=XXII$, $Z_A = ZZII$, $Z_B = ZIZI$, up to multiplication by stabilizers.\n\nWe will consider different state preparation circuits consisting of controlled not $CNOT_{ij}$ gates, where $CNOT_{ij}$ has control qubit $i$ and target qubit $j$. As a simple model of quantum errors in hardware, we will suppose that each $CNOT_{ij}$ gate in the circuit has a two qubit depolarizing error channel following it that produces one of the 15 non-identity two-qubit Paulis with equal probability $p/15$. The probability $p$ indicates the probability of an error in a single two-qubit gate. We will assess the logical infidelity of certain state preparation protocols as a function of the physical infidelity $p$.\n\n## Subproblem 1:\n\nSuppose that we wish to prepare a logical two-qubit GHZ state  $(|00\\rangle_{AB}+|11\\rangle_{AB})/\\sqrt{2}$ in the [[4,2,2]] code. To do so, we use the following state preparation circuit:\n\n$$ (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). $$\n\nNote that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). $H$ is a single-qubit Hadamard gate.\n\nWhat is the physical state fidelity of the final physical 4-qubit state at the end of the circuit as a function of the two-qubit gate error rate $p$?\n\n### Answer:\n$\nF_{\\rm{physical}}=(1-\\frac{12}{15}p)^2\n$\n\n## Subproblem 2:\n\nSuppose that we wish to prepare a logical two-qubit GHZ state  $(|00\\rangle_{AB}+|11\\rangle_{AB})/\\sqrt{2}$ in the [[4,2,2]] code. To do so, we use the following state preparation circuit:\n\n$$ (CNOT_{03}) (H_0) (CNOT_{21}) (H_2). $$\n\nNote that this equation is written in matrix multiplication order, while the quantum operations in the circuit occur in the reverse order (from right-to-left in the above equation). $H$ is a single-qubit Hadamard gate.\n\nWhat is the logical state fidelity of the final 2-qubit logical state at the end of the circuit as a function of the two-qubit gate error rate $p$, assuming the state is post-selected on all detectable errors in the code?",
      "code_template": "import sympy as sp\n\np = sp.symbols('p')\n\ndef answer(p):\n    r\"\"\"\n    Return the expression of the logical state fidelity of the final 2-qubit logical state\n    at the end of the circuit as a function of two-qubit gate error rate $p$.\n\n    Inputs\n    ----------\n    p: sympy.Symbol, two-qubit gate error rate, $p$\n\n    Outputs\n    ----------\n    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state\n    \"\"\"\n\n    # ------------------ FILL IN YOUR RESULTS BELOW ------------------\n    F_logical = ...  # a SymPy expression of inputs\n    # ---------------------------------------------------------------\n\n    return F_logical",
      "answer_code": "import sympy as sp\n\np = sp.symbols('p')\n\ndef real_answer(p):\n    r\"\"\"\n    Return the expression of the logical state fidelity of the final 2-qubit logical state\n    at the end of the circuit as a function of two-qubit gate error rate $p$.\n\n    Inputs\n    ----------\n    p: sympy.Symbol, two-qubit gate error rate, $p$\n\n    Outputs\n    ----------\n    F_logical: sympy.Expr, logical state fidelity of the final 2-qubit logical state\n    \"\"\"\n\n    # ------------------ FILL IN YOUR RESULTS BELOW ------------------\n    F_logical = 1 - (sp.Rational(16, 25)* p**2 - sp.Rational(128, 125)* p**3 + sp.Rational(2048, 3375)* p**4 - sp.Rational(32768, 253125)* p**5) / (1 - sp.Rational(68, 15)* p + sp.Rational(704, 75)* p**2 - sp.Rational(32768, 3375)* p**3 + sp.Rational(253952, 50625)* p**4 - sp.Rational(262144, 253125)* p**5)\n    # ---------------------------------------------------------------\n\n    return F_logical",
      "answer_only_code": "F_logical = 1 - (sp.Rational(16, 25)* p**2 - sp.Rational(128, 125)* p**3 + sp.Rational(2048, 3375)* p**4 - sp.Rational(32768, 253125)* p**5) / (1 - sp.Rational(68, 15)* p + sp.Rational(704, 75)* p**2 - sp.Rational(32768, 3375)* p**3 + sp.Rational(253952, 50625)* p**4 - sp.Rational(262144, 253125)* p**5)",
      "testcases": null,
      "metadata": {
        "settings": {},
        "sub_problem_index": 2,
        "notebook_path": "data/example_challenges/quantum_error_correction.ipynb"
      }
    }
  ]
}